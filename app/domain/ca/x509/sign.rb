# frozen_string_literal: true

require 'command_class'

module CA
  # :reek:UncommunicativeModuleName
  module X509
    # Responsible for signing a certificate request and returning the x.509 certificate
    class Sign
      extend CommandClass::Include

      command_class(
        dependencies: { webservice: nil, env: ENV },
        inputs: %i(certificate_request)
      ) do

        def call
          Certificate.new(certificate: signed_certificate)
        end

        private

        attr_reader :certificate_request, :webservice

        def signed_certificate          
          Util::OpenSsl::X509::Certificate.from_hash(
            subject: subject,
            issuer: issuer.subject,
            issuer_cert: issuer.certificate,
            public_key: csr.public_key,
            good_for: good_for,
            extensions: extensions
          ).tap do |cert|
            cert.sign(issuer.private_key, OpenSSL::Digest::SHA256.new)
          end
        end

        def csr
          @csr ||= ::Util::OpenSsl::X509::SmartCsr.new(certificate_request.params[:csr])
        end

        def issuer
          @issuer ||= ::CA::X509::Issuer.new(service: webservice)
        end

        def extensions
          [
            ['basicConstraints', basic_constraints, true],
            ['keyUsage', key_usage, true],
            ['subjectKeyIdentifier', 'hash', false],
            ['authorityKeyIdentifier', 'keyid:always,issuer:always', false],
            ['subjectAltName', subject_alt_names, false],
            ['nsComment', 'Generated by CyberArk Conjur', false]
          ].tap do |extensions|
            extensions << ['extendedKeyUsage', extended_key_usage, false] if extended_key_usage
          end
        end

        def basic_constraints
          certificate_use == :ca ? "CA:TRUE,pathlen:#{path_len}" : 'CA:FALSE'
        end

        def path_len
          certificate_request.params.fetch(:path_length, 0)
        end

        def key_usage
          case certificate_use
          when :ca
            'keyCertSign,cRLSign'
          when :client
            'digitalSignature'
          when :server
            'keyEncipherment'
          end
        end

        def extended_key_usage
          case certificate_use
          when :client
            "clientAuth"
          when :server
            "serverAuth"
          end
        end

        def certificate_use
          @certificate_use ||= certificate_request.params.fetch(:use, 'server')
            .downcase.to_sym
            .tap do |use|
            raise InvalidCertificateUse unless %i(server client ca).include?(use)
          end
        end
  
        def good_for
          [ttl, webservice.max_ttl].min
        end

        def ttl
          ttl_data = certificate_request.params[:ttl]
          @ttl ||= if ttl_data.present?
            ISO8601::Duration.new(ttl_data).to_seconds 
          else
            webservice.max_ttl
          end
        end
  
        def subject
          common_name = [
            role.account,
            webservice.service_id,
            role.kind,
            role.identifier
          ].join(':')
          OpenSSL::X509::Name.new [['CN', common_name]]
        end
  
        def subject_alt_names
          [
            "DNS:#{leaf_domain_name}",
            "URI:#{spiffe_id}"
          ].join(', ')
        end
  
        def leaf_domain_name
          role.identifier.split('/').last
        end

        def spiffe_id
          @spiffe_id ||= SpiffeId.new(issuer_id: webservice.service_id, role: role)
        end

        def role
          certificate_request.role
        end
      end
    end
  end
end
